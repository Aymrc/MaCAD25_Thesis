<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Massing Graph Viewer — Simplified Tags</title>
    <style>
      html, body, #graph { margin:0; height:100%; overflow:hidden; }
      #file { position:absolute; z-index:10; top:10px; left:10px; background:#fff; }

      /* Legend */
      #legend {
        position: absolute;
        top: 10px; right: 10px;
        z-index: 11;
        background: rgba(255,255,255,0.95);
        border: 1px solid #e3e3e3;
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.08);
        padding: 10px 12px;
        max-width: 280px;
        max-height: 60vh;
        overflow: auto;
        font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      #legend h4 {
        margin: 0 0 8px 0;
        font-size: 13px;
        font-weight: 700;
        letter-spacing: .2px;
      }
      .legend-item {
        display: flex; align-items: center; gap: 8px;
        margin: 4px 0;
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      }
      .legend-swatch {
        width: 14px; height: 14px; border-radius: 3px;
        border: 1px solid rgba(0,0,0,0.12);
        flex: 0 0 auto;
      }
      .legend-label {
        flex: 1 1 auto; overflow: hidden; text-overflow: ellipsis;
      }
      .legend-count {
        color: #888; font-size: 12px; flex: 0 0 auto;
      }
      .legend-controls {
        margin-top: 8px; padding-top: 8px; border-top: 1px dashed #e6e6e6;
        color: #666; font-size: 12px;
      }
      .legend-controls label { display: flex; align-items: center; gap: 6px; cursor: pointer; }
      .kbd {
        display: inline-block; padding: 1px 5px; border: 1px solid #ccc; border-bottom-width: 2px;
        border-radius: 4px; font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        background: #fff; color: #333;
      }
    </style>

    <!-- 1) Load THREE first (global) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <!-- 2) Then load the UMD build of 3d-force-graph that uses window.THREE -->
    <script src="https://cdn.jsdelivr.net/npm/3d-force-graph@1.73.5/dist/3d-force-graph.min.js"></script>
  </head>

  <body>
    <input type="file" id="file" accept=".json"/>
    <div id="legend" hidden>
      <h4>Program legend</h4>
      <div id="legend-items"></div>
      <div class="legend-controls">
        <label title="Toggle raw JSON-like tooltips">
          <input type="checkbox" id="toggle-raw" />
          Show raw properties
          <span style="margin-left:auto; opacity:.7">(<span class="kbd">R</span>)</span>
        </label>
      </div>
    </div>
    <div id="graph"></div>

    <script>
      if (!window.THREE) {
        console.error('THREE is not defined. Check script order/CDN reachability.');
      }

      const mount = document.getElementById('graph');
      // Label mode: false = human-friendly (default), true = raw
      let SHOW_RAW = false;

      const Graph = ForceGraph3D()(mount).nodeLabel(n => SHOW_RAW ? rawTagHtml(n) : humanLabelHtml(n));

      // ------------ palette + color map ------------
      const PALETTE = [
        '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
        '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
        '#393b79','#637939','#8c6d31','#843c39','#7b4173'
      ];
      const UNASSIGNED_COLOR = '#bdbdbd';

      function buildColorMap(categories) {
        const map = new Map();
        let i = 0;
        categories.forEach(cat => {
          if (cat === 'unassigned') {
            map.set(cat, UNASSIGNED_COLOR);
          } else if (!map.has(cat)) {
            map.set(cat, PALETTE[i % PALETTE.length]);
            i++;
          }
        });
        return map;
      }

      // ------------ helpers ------------
      function levelIndex(id) {
        const i = id?.indexOf?.('-L');
        if (i >= 0) {
          const s = id.slice(i + 2);
          const n = parseInt(s, 10);
          return isNaN(n) ? 0 : n;
        }
        return 0;
      }

      function derivePrimaryProgram(node) {
        if (node.primary_program) return node.primary_program;
        const arr = Array.isArray(node.program_assignments) ? node.program_assignments.slice() : [];
        if (!arr.length) return 'unassigned';
        arr.sort((a, b) => (b.area ?? 0) - (a.area ?? 0));
        return arr[0].program_id || 'unassigned';
      }

      // --- NEW: curated, human-friendly label content ---
      function humanLabelRows(n) {
        const rows = [];

        // Name/ID at top handled in HTML builder

        // Program (top 1-2 with % if areas present)
        const arr = Array.isArray(n.program_assignments) ? n.program_assignments.slice() : [];
        if (arr.length) {
          arr.sort((a,b) => (b.area ?? 0) - (a.area ?? 0));
          const total = arr.reduce((s,p) => s + (p.area ?? 0), 0);
          const top2 = arr.slice(0,2).map(p => {
            const pct = total > 0 ? Math.round(((p.area ?? 0) / total) * 100) : null;
            return pct != null ? `${p.program_id} (${pct}%)` : String(p.program_id);
          }).join(', ');
          const extra = arr.length > 2 ? ` +${arr.length - 2} more` : '';
          rows.push(['Program', top2 + extra]);
        } else {
          rows.push(['Program', derivePrimaryProgram(n)]);
        }

        // Level & Building
        const lvl = (n.level ?? levelIndex(n.id || ''));
        if (Number.isFinite(lvl)) rows.push(['Level', `L${lvl}`]);
        if (n.building_id) rows.push(['Building', n.building_id]);

        // Area (choose best available numeric key)
        const areaKey = ['area','net_area','gross_area','gfa','sqm','m2'].find(k => Number.isFinite(Number(n[k])));
        if (areaKey) {
          try {
            const val = Number(n[areaKey]);
            rows.push(['Area', `${val.toLocaleString(undefined, {maximumFractionDigits:1})} m²`]);
          } catch(_) {
            rows.push(['Area', `${n[areaKey]} m²`]);
          }
        }

        // Optional: other human-ish fields if present
        const OPTIONALS = [
          ['type','Type'],
          ['use','Use'],
          ['status','Status'],
          ['capacity','Capacity'],
          ['height','Height'],
          ['name','Name'],
          ['zone','Zone'],
        ];
        OPTIONALS.forEach(([key, label]) => {
          const v = n[key];
          if (v != null && typeof v !== 'object') rows.push([label, String(v)]);
        });

        return rows;
      }

      function escapeHtml(s) {
        return String(s).replace(/[&<>\"']/g, m => ({
          '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
        }[m]));
      }

      function humanLabelHtml(n) {
        const title = n.id ? `<div style="font-weight:700;margin-bottom:6px">${escapeHtml(n.id)}</div>` : '';
        const rows = humanLabelRows(n).map(([k, v]) =>
          `<div><span style="opacity:.7">${escapeHtml(k)}:</span> ${escapeHtml(v)}</div>`
        ).join('');
        return `<div style="max-width:320px">${title}${rows}</div>`;
      }

      // --- Raw fallback (previous behavior) ---
      function tagsFromNode(n) {
        const entries = [];
        for (const [k, v] of Object.entries(n)) {
          if (k === 'x' || k === 'y' || k === 'z') continue;
          if (k.startsWith('_')) continue; // hide internal
          if (k === 'program_assignments' && Array.isArray(v)) {
            const txt = v.map(p => `${p.program_id}:${(p.area ?? 0).toFixed(1)}sqm`).join(', ');
            entries.push([k, txt]);
          } else if (typeof v === 'object' && v !== null) {
            // keep objects terse
            entries.push([k, '[object]']);
          } else {
            entries.push([k, String(v)]);
          }
        }
        return entries;
      }
      function rawTagHtml(n) {
        const tags = tagsFromNode(n);
        const title = n.id ? `<div style="font-weight:700;margin-bottom:6px">${escapeHtml(n.id)}</div>` : '';
        const rows = tags.map(([k, v]) =>
          `<div><span style="opacity:.7">${escapeHtml(k)}:</span> ${escapeHtml(v)}</div>`
        ).join('');
        return `<div style="max-width:360px">${title}${rows}</div>`;
      }

      // --- Canvas-based text sprite using global THREE ---
      function makeTextSprite(text) {
        const fontSize = 60;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        ctx.font = `600 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
        const textW = ctx.measureText(text).width;
        const textH = fontSize * 1.4;

        canvas.width = Math.ceil(textW + 30);
        canvas.height = Math.ceil(textH + 20);

        ctx.font = `600 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.96)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'rgba(0,0,0,0.12)';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#111';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 15, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.minFilter = THREE.LinearFilter;

        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          depthWrite: false
        });

        const sprite = new THREE.Sprite(material);
        sprite.scale.set(canvas.width * 0.1, canvas.height * 0.1, 1);
        return sprite;
      }

      // ------------ data preparation ------------
      function prepareData(data) {
        const nodes = (data.nodes || []).map(n => {
          const lvl = (n.level ?? levelIndex(n.id || '')) ?? 0;
          const bld = n.building_id || '';
          n.programKey = derivePrimaryProgram(n) || 'unassigned';
          n._alwaysLabel = `L${lvl}${bld ? ' ' + bld : ''}`;
          return n;
        });
        const links = data.links || data.edges || [];
        return { nodes, links };
      }

      function updateLegend(colorMap, nodes) {
        const legend = document.getElementById('legend');
        const container = document.getElementById('legend-items');
        container.innerHTML = '';
        const counts = nodes.reduce((acc, n) => {
          const k = n.programKey || 'unassigned';
          acc[k] = (acc[k] || 0) + 1;
          return acc;
        }, {});
        const cats = Array.from(colorMap.keys()).sort((a, b) => {
          if (a === 'unassigned') return 1;
          if (b === 'unassigned') return -1;
          return a.localeCompare(b);
        });
        cats.forEach(cat => {
          const item = document.createElement('div');
          item.className = 'legend-item';
          const swatch = document.createElement('span');
          swatch.className = 'legend-swatch';
          swatch.style.background = colorMap.get(cat);
          item.appendChild(swatch);
          const label = document.createElement('span');
          label.className = 'legend-label';
          label.textContent = cat;
          item.appendChild(label);
          const count = document.createElement('span');
          count.className = 'legend-count';
          count.textContent = counts[cat] ?? 0;
          item.appendChild(count);
          container.appendChild(item);
        });
        legend.hidden = cats.length === 0;

        // wire toggle each time legend is updated
        const toggle = document.getElementById('toggle-raw');
        if (toggle) {
          toggle.checked = SHOW_RAW;
          toggle.onchange = () => { SHOW_RAW = toggle.checked; };
        }
      }

      function applyColors(nodes, colorMap) {
        Graph.nodeColor(node => colorMap.get(node.programKey) || UNASSIGNED_COLOR);
      }

      // ------------ load + sticky labels ------------
      function loadGraph(data) {
        const prepared = prepareData(data);

        // degree to detect leaves
        const deg = new Map();
        prepared.nodes.forEach(n => deg.set(n.id, 0));
        prepared.links.forEach(l => {
          const a = l.source?.id ?? l.source;
          const b = l.target?.id ?? l.target;
          if (deg.has(a)) deg.set(a, deg.get(a) + 1);
          if (deg.has(b)) deg.set(b, deg.get(b) + 1);
        });
        prepared.nodes.forEach(n => { n._isLeaf = (deg.get(n.id) ?? 0) <= 1; });

        const categories = new Set(prepared.nodes.map(n => n.programKey || 'unassigned'));
        const colorMap = buildColorMap(categories);
        applyColors(prepared.nodes, colorMap);
        updateLegend(colorMap, prepared.nodes);

        Graph
          .nodeThreeObjectExtend(true)
          .nodeThreeObject(node => {
            if (!node._isLeaf || !window.THREE) return null;
            const sprite = makeTextSprite(node._alwaysLabel);
            sprite.position.set(0, 8, 0);
            return sprite;
          });

        Graph.graphData(prepared);
      }

      // key toggle for raw labels
      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'r') {
          SHOW_RAW = !SHOW_RAW;
          const toggle = document.getElementById('toggle-raw');
          if (toggle) toggle.checked = SHOW_RAW;
        }
      });

      // ------------ default load ------------
      const defaultPath = '../enriched_graph/iteration/it2.json';
      fetch(defaultPath)
        .then(res => res.ok ? res.json() : Promise.reject(res.status))
        .then(loadGraph)
        .catch(err => console.warn('Could not load default graph:', err));

      // file input
      document.getElementById('file').addEventListener('change', e => {
        const f = e.target.files[0];
        if (!f) return;
        const r = new FileReader();
        r.onload = () => {
          try { loadGraph(JSON.parse(r.result)); }
          catch (err) { console.error('Invalid JSON:', err); }
        };
        r.readAsText(f);
      });
    </script>
  </body>
</html>
