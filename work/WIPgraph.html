<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Massing Graph Viewer</title>
    <style>
      html, body, #graph { margin:0; height:100%; overflow:hidden; }
      #file { position:absolute; z-index:10; top:10px; left:10px; background:#fff; }

      /* Legend */
      #legend {
        position: absolute;
        top: 10px; right: 10px;
        z-index: 11;
        background: rgba(255,255,255,0.95);
        border: 1px solid #e3e3e3;
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.08);
        padding: 10px 12px;
        max-width: 260px;
        max-height: 60vh;
        overflow: auto;
        font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      #legend h4 {
        margin: 0 0 8px 0;
        font-size: 13px;
        font-weight: 700;
        letter-spacing: .2px;
      }
      .legend-item {
        display: flex; align-items: center; gap: 8px;
        margin: 4px 0;
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      }
      .legend-swatch {
        width: 14px; height: 14px; border-radius: 3px;
        border: 1px solid rgba(0,0,0,0.12);
        flex: 0 0 auto;
      }
      .legend-label {
        flex: 1 1 auto; overflow: hidden; text-overflow: ellipsis;
      }
      .legend-count {
        color: #888; font-size: 12px; flex: 0 0 auto;
      }
    </style>
    <script src="https://unpkg.com/3d-force-graph"></script>
  </head>

  <body>
    <input type="file" id="file" accept=".json"/>
    <div id="legend" hidden>
      <h4>Program legend</h4>
      <div id="legend-items"></div>
    </div>
    <div id="graph"></div>

    <script>
      const mount = document.getElementById('graph');
      const Graph = ForceGraph3D()(mount)
        .nodeLabel(n => tagHtml(n));

      // ------------ palette + color map ------------
      // Plotly/D3 Category10-ish palette; cycles if categories > palette length.
      const PALETTE = [
        '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
        '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
        '#393b79','#637939','#8c6d31','#843c39','#7b4173'
      ];
      const UNASSIGNED_COLOR = '#bdbdbd';

      function buildColorMap(categories) {
        const map = new Map();
        let i = 0;
        categories.forEach(cat => {
          if (cat === 'unassigned') {
            map.set(cat, UNASSIGNED_COLOR);
          } else if (!map.has(cat)) {
            map.set(cat, PALETTE[i % PALETTE.length]);
            i++;
          }
        });
        return map;
      }

      // ------------ helpers ------------
      function levelIndex(id) {
        const i = id?.indexOf?.('-L');
        if (i >= 0) {
          const s = id.slice(i + 2);
          const n = parseInt(s, 10);
          return isNaN(n) ? 0 : n;
        }
        return 0;
      }

      function derivePrimaryProgram(node) {
        if (node.primary_program) return node.primary_program;
        const arr = Array.isArray(node.program_assignments) ? node.program_assignments.slice() : [];
        if (!arr.length) return 'unassigned';
        arr.sort((a, b) => (b.area ?? 0) - (a.area ?? 0));
        return arr[0].program_id || 'unassigned';
      }

      function tagsFromNode(node) {
        const entries = [];
        for (const [k, v] of Object.entries(node)) {
          if (k === 'x' || k === 'y' || k === 'z') continue;
          if (k === 'program_assignments' && Array.isArray(v)) {
            const txt = v.map(p => `${p.program_id}:${(p.area ?? 0).toFixed(1)}sqm`).join(', ');
            entries.push([k, txt]);
          } else if (typeof v === 'object' && v !== null) {
            entries.push([k, JSON.stringify(v)]);
          } else {
            entries.push([k, String(v)]);
          }
        }
        return entries;
      }

      function escapeHtml(s) {
        return String(s).replace(/[&<>\"']/g, m => ({
          '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
        }[m]));
      }

      function tagHtml(n) {
        const tags = tagsFromNode(n);
        const title = n.id ? `<div style="font-weight:700;margin-bottom:6px">${escapeHtml(n.id)}</div>` : '';
        const rows = tags.map(([k, v]) =>
          `<div><span style="opacity:.7">${escapeHtml(k)}:</span> ${escapeHtml(v)}</div>`
        ).join('');
        return `<div style="max-width:360px">${title}${rows}</div>`;
      }

      function prepareData(data) {
        const nodes = (data.nodes || []).map(n => {
          n.programKey = derivePrimaryProgram(n) || 'unassigned';
          n._label = `${n.building_id || ''} L${n.level ?? levelIndex(n.id || '')}`;
          n.tags = tagsFromNode(n).map(([k, v]) => `${k}:${v}`);
          return n;
        });
        const links = data.links || data.edges || [];
        return { nodes, links };
      }

      function updateLegend(colorMap, nodes) {
        const legend = document.getElementById('legend');
        const container = document.getElementById('legend-items');
        container.innerHTML = '';

        // Count nodes per category
        const counts = nodes.reduce((acc, n) => {
          const k = n.programKey || 'unassigned';
          acc[k] = (acc[k] || 0) + 1;
          return acc;
        }, {});

        // Stable order: unassigned last, otherwise by label
        const cats = Array.from(colorMap.keys()).sort((a, b) => {
          if (a === 'unassigned') return 1;
          if (b === 'unassigned') return -1;
          return a.localeCompare(b);
        });

        cats.forEach(cat => {
          const item = document.createElement('div');
          item.className = 'legend-item';

          const swatch = document.createElement('span');
          swatch.className = 'legend-swatch';
          swatch.style.background = colorMap.get(cat);
          item.appendChild(swatch);

          const label = document.createElement('span');
          label.className = 'legend-label';
          label.textContent = cat;
          item.appendChild(label);

          const count = document.createElement('span');
          count.className = 'legend-count';
          count.textContent = counts[cat] ?? 0;
          item.appendChild(count);

          container.appendChild(item);
        });

        legend.hidden = cats.length === 0;
      }

      function applyColors(nodes, colorMap) {
        Graph.nodeColor(node => colorMap.get(node.programKey) || UNASSIGNED_COLOR);
      }

      function loadGraph(data) {
        const prepared = prepareData(data);

        // Build a color map from current categories
        const categories = new Set(prepared.nodes.map(n => n.programKey || 'unassigned'));
        const colorMap = buildColorMap(categories);

        // Apply colors + legend, then render
        applyColors(prepared.nodes, colorMap);
        updateLegend(colorMap, prepared.nodes);
        Graph.graphData(prepared);
      }

      // ------------ default load ------------
      const defaultPath = '../knowledge/massing_graph_enriched.json'; // adjust if needed
      fetch(defaultPath)
        .then(res => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then(loadGraph)
        .catch(err => console.warn('Could not load default graph:', err));

      // ------------ file input ------------
      document.getElementById('file').addEventListener('change', e => {
        const f = e.target.files[0];
        if (!f) return;
        const r = new FileReader();
        r.onload = () => {
          try {
            const data = JSON.parse(r.result);
            loadGraph(data);
          } catch (err) {
            console.error('Invalid JSON:', err);
          }
        };
        r.readAsText(f);
      });
    </script>
  </body>
</html>
